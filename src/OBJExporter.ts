import {
  Color,
  Matrix3,
  Vector2,
  Vector3,
  Object3D,
  Mesh,
  Line,
  Points,
  Material,
  Texture,
} from "three";
import { zipSync, strToU8 } from "fflate";

// Define an interface for texture map types
interface TextureMapType {
  prop: string;
  mtlKey: string;
  extension: string;
}

// Define an interface for exported textures
interface ExportedTexture {
  name: string;
  src: string;
}

// Define the texture map types array
const textureMapTypes: TextureMapType[] = [
  // Diffuse/Base Color Map
  {
    prop: "map",
    mtlKey: "map_Kd",
    extension: "png",
  },
  // Ambient Occlusion Map
  {
    prop: "aoMap",
    mtlKey: "map_Ao",
    extension: "png",
  },
  // Emissive Map
  {
    prop: "emissiveMap",
    mtlKey: "map_Ke",
    extension: "png",
  },
  // Specular Map
  {
    prop: "specularMap",
    mtlKey: "map_Ks",
    extension: "png",
  },
  // Bump Map
  {
    prop: "bumpMap",
    mtlKey: "map_bump",
    extension: "png",
  },
  // Normal Map
  {
    prop: "normalMap",
    mtlKey: "map_normal",
    extension: "png",
  },
  // Displacement Map
  {
    prop: "displacementMap",
    mtlKey: "disp",
    extension: "png",
  },
  // Roughness Map
  {
    prop: "roughnessMap",
    mtlKey: "map_roughness",
    extension: "png",
  },
  // Metalness Map
  {
    prop: "metalnessMap",
    mtlKey: "map_metalness",
    extension: "png",
  },
  // Alpha Map
  {
    prop: "alphaMap",
    mtlKey: "map_d",
    extension: "png",
  },
  // Environment Map
  {
    prop: "envMap",
    mtlKey: "map_env",
    extension: "png",
  },
  // Light Map
  {
    prop: "lightMap",
    mtlKey: "map_light",
    extension: "png",
  },
  // Gradient Map
  {
    prop: "gradientMap",
    mtlKey: "map_gradient",
    extension: "png",
  },
  // Sheen Map (Non-standard, added for completeness)
  {
    prop: "sheenMap",
    mtlKey: "map_sheen",
    extension: "png",
  },
  // Transmission Map (Non-standard, added for completeness)
  {
    prop: "transmissionMap",
    mtlKey: "map_transmission",
    extension: "png",
  },
  // Clearcoat Map (Non-standard, added for completeness)
  {
    prop: "clearcoatMap",
    mtlKey: "map_clearcoat",
    extension: "png",
  },
  // Clearcoat Roughness Map (Non-standard, added for completeness)
  {
    prop: "clearcoatRoughnessMap",
    mtlKey: "map_clearcoat_roughness",
    extension: "png",
  },
  // Transmission Roughness Map (Non-standard, added for completeness)
  {
    prop: "transmissionRoughnessMap",
    mtlKey: "map_transmission_roughness",
    extension: "png",
  },
];

// Define the OBJMTLExporter class
export class OBJMTLExporter {
  /**
   * Parses a Three.js Object3D and generates OBJ and MTL file contents along with texture data.
   * @param object - The Three.js Object3D to export.
   * @returns A promise that resolves with the OBJ, MTL, and textures data.
   */
  parse(object: Object3D): Promise<{
    obj: string;
    mtl: string;
    textures: ExportedTexture[];
  }> {
    return new Promise((resolve, reject) => {
      try {
        let objOutput = "";
        let mtlOutput = "";
        const materialsSet: Set<Material> = new Set();
        const textures: { name: string; image: any; flipY: boolean }[] = []; // Array to store texture data

        let indexVertex = 0;
        let indexVertexUvs = 0;
        let indexNormals = 0;

        const vertex = new Vector3();
        const color = new Color();
        const normal = new Vector3();
        const uv = new Vector2();

        const face: string[] = [];

        // Helper to collect unique materials
        const collectMaterials = (material: Material | Material[]) => {
          if (Array.isArray(material)) {
            material.forEach((mat) => {
              if (mat && (mat as any).name) {
                materialsSet.add(mat);
              }
            });
          } else {
            if (material && (material as any).name) {
              materialsSet.add(material);
            }
          }
        };

        // First pass: collect all materials
        object.traverse((child) => {
          if ((child as Mesh).isMesh) {
            collectMaterials((child as Mesh).material);
          }
        });

        // Assign material indices
        const materials = Array.from(materialsSet);
        const materialNameMap = new WeakMap<Material, string>();

        // Generate MTL content
        if (materials.length > 0) {
          mtlOutput += "# MTL file generated by OBJMTLExporter\n\n";
          materials.forEach((mat) => {
            const matName =
              (mat as any).name || `material_${materials.indexOf(mat)}`;
            mtlOutput += `newmtl ${matName}\n`;
            // materialMap[matName] = mat;
            materialNameMap.set(mat, matName);
            // Base color
            if ((mat as any).color) {
              const matColor = (mat as any).color as Color;
              mtlOutput += `Kd ${matColor.r} ${matColor.g} ${matColor.b}\n`;
            }

            // Specular color
            if ((mat as any).specular) {
              const matSpecular = (mat as any).specular as Color;
              mtlOutput += `Ks ${matSpecular.r} ${matSpecular.g} ${matSpecular.b}\n`;
            }

            // Ambient color
            if ((mat as any).ambient) {
              const matAmbient = (mat as any).ambient as Color;
              mtlOutput += `Ka ${matAmbient.r} ${matAmbient.g} ${matAmbient.b}\n`;
            }

            // Shininess
            if ((mat as any).shininess !== undefined) {
              mtlOutput += `Ns ${(mat as any).shininess}\n`;
            }

            // Transparency
            if ((mat as any).opacity !== undefined) {
              mtlOutput += `d ${(mat as any).opacity}\n`;
            }

            const texturesMap = new Map<string, Texture>();
            // Handle texture maps
            textureMapTypes.forEach((mapType) => {
              const map = (mat as any)[mapType.prop] as Texture | null;
              if (map && map.image) {
                const textureName = map.name || `${matName}_${mapType.mtlKey}`;
                const extension = mapType.extension || "png";
                let textureNameWithExtension = `${textureName}.${extension}`;
                //check if texture with same  name already exists
                let duplicateName: null | string = null;
                let duplicateTexture: null | Texture = null;
                texturesMap.forEach((texture, name) => {
                  if (
                    name === textureNameWithExtension &&
                    texture !== map &&
                    !duplicateName
                  ) {
                    duplicateName = name;
                  } else if (
                    texture === map &&
                    name !== textureNameWithExtension
                  ) {
                    duplicateName = name;
                    duplicateTexture = texture;
                  } else if (
                    texture === map &&
                    name === textureNameWithExtension
                  ) {
                    duplicateName = name;
                    duplicateTexture = texture;
                  }
                });

                if (duplicateName && !duplicateTexture) {
                  textureNameWithExtension = `${textureName}_${mapType.mtlKey}.${extension}`;
                } else if (duplicateName && duplicateTexture) {
                  textureNameWithExtension = duplicateName;
                }

                mtlOutput += `${mapType.mtlKey} ${textureNameWithExtension}\n`;
                if (!duplicateTexture) {
                  // Collect textures for exporting
                  textures.push({
                    name: textureNameWithExtension,
                    image: map.image,
                    flipY: map.flipY,
                  });
                  map.name = textureNameWithExtension;
                  texturesMap.set(textureNameWithExtension, map);
                }
              }
            });

            mtlOutput += "\n";
          });
        }

        // Add MTL reference to OBJ
        if (materials.length > 0) {
          objOutput += `mtllib materials.mtl\n\n`;
        }

        /**
         * Parses a mesh and appends its data to the OBJ and MTL outputs.
         * @param mesh - The mesh to parse.
         */
        const parseMesh = (mesh: Mesh) => {
          let nbVertex = 0;
          let nbNormals = 0;
          let nbVertexUvs = 0;

          const geometry = mesh.geometry;

          const normalMatrixWorld = new Matrix3();

          // Shortcuts to geometry attributes
          const vertices = geometry.getAttribute("position");
          const normalsAttr = geometry.getAttribute("normal");
          const uvs = geometry.getAttribute("uv");
          const indices = geometry.index;

          // Name of the mesh object
          objOutput += `o ${mesh.name || "Object"}\n`;

          // Name of the mesh material
          if (mesh.material && (mesh.material as any).name) {
            //find name of material in materialNameMap
            //@ts-expect-error : materialMap is not defined
            const matName = materialNameMap.get(mesh.material);
            if (!matName) throw new Error("Material not found");
            objOutput += `usemtl ${matName}\n`;
          }

          // Vertices
          if (vertices) {
            for (let i = 0; i < vertices.count; i++) {
              vertex.fromBufferAttribute(vertices, i);
              // Transform the vertex to world space
              vertex.applyMatrix4(mesh.matrixWorld);
              // Export format
              objOutput += `v ${vertex.x} ${vertex.y} ${vertex.z}\n`;
              nbVertex++;
            }
          }

          // UVs
          if (uvs) {
            for (let i = 0; i < uvs.count; i++) {
              //@ts-expect-error : Need to check if it supports InterleavedBufferAttribute
              uv.fromBufferAttribute(uvs, i);
              objOutput += `vt ${uv.x} ${uv.y}\n`;
              nbVertexUvs++;
            }
          }

          // Normals
          if (normalsAttr) {
            normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
            for (let i = 0; i < normalsAttr.count; i++) {
              normal.fromBufferAttribute(normalsAttr, i);
              // Transform the normal to world space
              normal.applyMatrix3(normalMatrixWorld).normalize();
              objOutput += `vn ${normal.x} ${normal.y} ${normal.z}\n`;
              nbNormals++;
            }
          }

          // Faces
          if (indices) {
            for (let i = 0; i < indices.count; i += 3) {
              for (let m = 0; m < 3; m++) {
                const j = indices.getX(i + m) + 1;
                face[m] = `${indexVertex + j}${
                  uvs || normalsAttr
                    ? `/${uvs ? indexVertexUvs + j : ""}${
                        normalsAttr ? `/${indexNormals + j}` : ""
                      }`
                    : ""
                }`;
              }
              objOutput += `f ${face.join(" ")}\n`;
            }
          } else {
            // Non-indexed geometry
            for (let i = 0; i < vertices.count; i += 3) {
              for (let m = 0; m < 3; m++) {
                const j = i + m + 1;
                face[m] = `${indexVertex + j}${
                  uvs || normalsAttr
                    ? `/${uvs ? indexVertexUvs + j : ""}${
                        normalsAttr ? `/${indexNormals + j}` : ""
                      }`
                    : ""
                }`;
              }
              objOutput += `f ${face.join(" ")}\n`;
            }
          }

          // Update indices
          indexVertex += nbVertex;
          indexVertexUvs += nbVertexUvs;
          indexNormals += nbNormals;
        };

        /**
         * Parses a line and appends its data to the OBJ output.
         * @param line - The line to parse.
         */
        const parseLine = (line: Line) => {
          let nbVertex = 0;

          const geometry = line.geometry;
          const type = line.type;

          // Shortcuts to geometry attributes
          const vertices = geometry.getAttribute("position");

          // Name of the line object
          objOutput += `o ${line.name || "Line"}\n`;

          if (vertices) {
            for (let i = 0; i < vertices.count; i++) {
              vertex.fromBufferAttribute(vertices, i);
              // Transform the vertex to world space
              vertex.applyMatrix4(line.matrixWorld);
              objOutput += `v ${vertex.x} ${vertex.y} ${vertex.z}\n`;
              nbVertex++;
            }
          }

          if (type === "Line") {
            objOutput += "l ";
            for (let j = 1; j <= vertices.count; j++) {
              objOutput += `${indexVertex + j} `;
            }
            objOutput += "\n";
          }

          if (type === "LineSegments") {
            for (let j = 1; j < vertices.count; j += 2) {
              const k = j + 1;
              objOutput += `l ${indexVertex + j} ${indexVertex + k}\n`;
            }
          }

          // Update index
          indexVertex += nbVertex;
        };

        /**
         * Parses points and appends its data to the OBJ output.
         * @param points - The points to parse.
         */
        const parsePoints = (points: Points) => {
          let nbVertex = 0;

          const geometry = points.geometry;

          const vertices = geometry.getAttribute("position");
          const colors = geometry.getAttribute("color");

          // Name of the points object
          objOutput += `o ${points.name || "Points"}\n`;

          if (vertices) {
            for (let i = 0; i < vertices.count; i++) {
              vertex.fromBufferAttribute(vertices, i);
              vertex.applyMatrix4(points.matrixWorld);

              objOutput += `v ${vertex.x} ${vertex.y} ${vertex.z}`;

              if (colors) {
                color.fromBufferAttribute(colors, i).convertSRGBToLinear();
                objOutput += ` ${color.r} ${color.g} ${color.b}`;
              }

              objOutput += "\n";
              nbVertex++;
            }

            objOutput += "p ";

            for (let j = 1; j <= vertices.count; j++) {
              objOutput += `${indexVertex + j} `;
            }

            objOutput += "\n";
          }

          // Update index
          indexVertex += nbVertex;
        };

        // Traverse the object and parse each child
        object.traverse((child) => {
          if ((child as Mesh).isMesh) {
            parseMesh(child as Mesh);
          } else if ((child as Line).isLine) {
            parseLine(child as Line);
          } else if ((child as Points).isPoints) {
            parsePoints(child as Points);
          }
        });

        // Create a canvas for texture processing
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas 2D context"));
          return;
        }

        // Prepare textures for export
        const texturePromises: Promise<ExportedTexture>[] = textures.map(
          (texture) => {
            return new Promise((res, rej) => {
              const img = texture.image;

              if (typeof img.src === "string") {
                // Image is loaded from a URL
                res({
                  name: texture.name,
                  src: img.src,
                });
              } else if (
                img instanceof Image ||
                img instanceof HTMLCanvasElement ||
                img instanceof ImageBitmap
              ) {
                // Convert Image to data URL
                canvas.width = img.width;
                canvas.height = img.height;

                // if (texture.flipY) {
                // Was doing based on textures FlipY prop even textures without FlipY seems to need to flip.
                ctx.save();
                ctx.scale(1, -1);
                ctx.drawImage(img as CanvasImageSource, 0, -img.height);
                ctx.restore();

                const dataURL = canvas.toDataURL("image/png");
                res({
                  name: texture.name,
                  src: dataURL,
                });
              } else {
                rej(new Error("Unsupported texture image format"));
              }
            });
          }
        );

        Promise.all(texturePromises)
          .then((exportedTextures) => {
            resolve({
              obj: objOutput,
              mtl: mtlOutput,
              textures: exportedTextures,
            });
            canvas.remove();
          })
          .catch(reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Exports the parsed OBJ, MTL, and textures data into a ZIP archive.
   * @param object - The Three.js Object3D to export.
   * @returns A promise that resolves with the ZIP file as a Uint8Array.
   */
  exportToZip(object: Object3D): Promise<Uint8Array> {
    return this.parse(object)
      .then((data) => {
        const files: { [path: string]: Uint8Array } = {};

        // Add OBJ and MTL files
        files["model.obj"] = strToU8(data.obj);
        files["materials.mtl"] = strToU8(data.mtl);

        // Add texture images
        const texturePromises = data.textures.map(async (texture) => {
          if (texture.src.startsWith("data:")) {
            // Convert data URL to binary
            const base64 = texture.src.split(",")[1];
            const binary = Uint8Array.from(atob(base64), (c) =>
              c.charCodeAt(0)
            );
            files[texture.name] = binary;
          } else {
            // Fetch texture from URL
            try {
              const response = await fetch(texture.src);
              if (!response.ok) {
                throw new Error(`Failed to fetch texture: ${texture.src}`);
              }
              const arrayBuffer = await response.arrayBuffer();
              files[texture.name] = new Uint8Array(arrayBuffer);
            } catch (error) {
              console.warn(`Could not fetch texture: ${texture.src}`, error);
            }
          }
        });

        return Promise.all(texturePromises).then(() => {
          // Create ZIP using fflate
          const zipped = zipSync(files, { level: 9 });
          return zipped;
        });
      })
      .catch((error) => {
        console.error("Error exporting model:", error);
        throw error; // Re-throw the error after logging
      });
  }
}
